use crate::crdt::crdt::crdt::ShoppingList;
use crate::database::*;
use crate::macros::*;
use crate::model::*;
use std::collections::HashMap;

use reqwest::blocking::Client;
use serde_json::json;
use uuid::Uuid;

use unqlite::UnQLite;

//TODO: an user maybe can have also a HashMap with list_Uuid -> list_name: A map of the lists the user have
/**
 * Creates a new user that will use the local app
 */
pub fn create_user(
    name: &str,
    age: u32,
    email: &str,
    db: &UnQLite,
) -> Result<String, &'static str> {
    let id = Uuid::new_v4().to_string();
    let new_user: User = User {
        node_id: id.clone(),
        name: name.to_string(),
        age: age,
        email: email.to_string(),
    };

    unwrap_or_return!(db.store_user(id.clone(), new_user, "Failed to store new user"));

    return Ok(id);
}

pub fn update_user_info(
    node_id: String,
    name: &str,
    age: u32,
    email: &str,
    db: &UnQLite,
) -> Result<bool, &'static str> {
    let mut user: User = unwrap_or_return!(db.get_user(node_id.clone()));

    user.name = name.to_string();
    user.age = age;
    user.email = email.to_string();

    return Ok(unwrap_or_return!(db.store_user(
        node_id,
        user,
        "Failed to store updated user"
    )));
}

pub fn get_user(id: String, db: &UnQLite) -> Result<User, &'static str> {
    return db.get_user(id);
}

/**
 *  Creates a new list and returns the created id
 * */
pub fn create_list(title: &str, node_id: Uuid, db: &UnQLite) -> Result<String, &'static str> {
    let mut id = Uuid::new_v4().to_string(); //TODO: change this, node_id is generated by the app for the user, before creating any list
                                             //TODO: the list_id can be a tuple (user_who_created_node_id_using_Uuid, list_id_using_Uuid), now we just use just Uuid
    while db.has_key(id.clone()) {
        id = Uuid::new_v4().to_string();
    }

    let new_list: ShoppingListData = ShoppingListData {
        list_info: ListInfo {
            list_id: id.clone(), //change this to an id using node_id from the user who create the list and a counter/ other information (eg: node_id_user_who_created_list, only-grow counter)
            title: title.to_string(),
            shared: false,
        },
        items_checked: HashMap::new(), //TODO: When an item is checked on the frontend, the name of the item with true value is inserted here. When the item is unchecked/removed the item_name -> True pair is removed
        crdt: ShoppingList::new_v2(node_id),
    };

    unwrap_or_return!(db.store(id.clone(), new_list, "Failed to store new list"));

    return Ok(id);
}

/**
 * Gets the data of a list
 */
pub fn get_list(db: &UnQLite, id: String) -> Result<ShoppingListData, &'static str> {
    return db.get_list(id);
}

/**
 * Gets information about every list in the database
 */
pub fn get_all_lists_info(db: &UnQLite) -> Result<Vec<ListInfo>, &'static str> {
    return db.get_all_lists_info();
}

/**
 *  Adds new list item to a specified list
 * */
pub fn add_item_to_list(
    list_id: String, // Adapt for the id (eg: node_id_user_who_created_list, only-grow counter)
    name: &str,
    qtd: i32,
    db: &UnQLite,
) -> Result<bool, &'static str> {
    let mut list = unwrap_or_return!(db.get_list(list_id.clone()));

    list.crdt
        .add_or_update_item(name.to_string(), qtd.unsigned_abs(), qtd < 0);

    return Ok(unwrap_or_return!(db.store(
        list_id,
        list,
        "Failed to store updated list"
    )));
}

/**
 *  Updates a specified list's title
 * */
pub fn update_list_title(list_id: String, title: &str, db: &UnQLite) -> Result<bool, &'static str> {
    let mut list: ShoppingListData = unwrap_or_return!(db.get_list(list_id.clone()));

    list.list_info.title = title.to_string();

    return Ok(unwrap_or_return!(db.store(
        list_id,
        list,
        "Failed to store updated list"
    )));
}

pub fn update_list_item(
    list_id: String,
    item_name: String,
    counter: u32,
    checked: bool,
    db: &UnQLite,
) -> Result<SimpleListItem, &'static str> {
    let mut list: ShoppingListData = unwrap_or_return!(db.get_list(list_id.clone()));

    let simple_list: SimpleShoppingList = list.simplified();

    if simple_list.items.contains_key(&item_name) {
        // if now checkd and previously wasn't, check item
        if checked == true && simple_list.items.get(&item_name).unwrap().checked != checked {
            let check_operation: bool =
                unwrap_or_return!(item_check(list_id, item_name.clone(), db));

            // If checked successfully the item will have his counter reset
            if check_operation {
                return Ok(SimpleListItem {
                    title: item_name,
                    counter: 0,
                    checked,
                });
            }
        } else {
            let item = simple_list.items.get(&item_name).unwrap();

            if item.counter != counter {
                if counter > item.counter {
                    list.crdt
                        .add_or_update_item(item_name.clone(), counter - item.counter, false)
                } else {
                    list.crdt
                        .add_or_update_item(item_name.clone(), item.counter - counter, true)
                }
            }

            match db.store(list_id, list, "Failed to store updated item quantity") {
                Ok(_) => {
                    return Ok(SimpleListItem {
                        title: item_name,
                        counter,
                        checked: item.checked,
                    })
                }
                Err(_) => {
                    return Ok(SimpleListItem {
                        title: item_name,
                        counter: item.counter,
                        checked: item.checked,
                    })
                }
            }
        }
    } else {
        return Err("Item with given key does not exist");
    }

    Ok(SimpleListItem {
        title: item_name,
        counter,
        checked,
    })
}
/**
 *  Update an item quantity to 0 when a user locally check an item as complete
 * */
pub fn item_check(list_id: String, item_name: String, db: &UnQLite) -> Result<bool, &'static str> {
    //TODO: test and do the frontend checkbox
    let mut list: ShoppingListData = unwrap_or_return!(db.get_list(list_id.clone()));
    //put item quantity to 0
    let reset_decrement = match list.crdt.items.get(&item_name) {
        Some(bounded_pn_counter) => bounded_pn_counter.get_count(),
        None => {
            return Err("Item not found in the list");
        }
    };

    list.crdt
        .add_or_update_item(item_name, reset_decrement, true);

    return Ok(unwrap_or_return!(db.store(
        list_id,
        list,
        "Failed to store updated item quantity"
    )));
}

pub fn publish_list(list_id: String, db: &UnQLite) -> Result<bool, &'static str> {
    let list = unwrap_or_return!(db.get_list(list_id.clone()));

    #[derive(serde::Serialize, serde::Deserialize, Clone, Debug)]
    struct List {
        list_id: String,
        content: ShoppingList,
    }

    let crdt_body = match serde_json::to_string(&List {
        list_id: list_id.clone(),
        content: list.crdt,
    }) {
        Ok(body) => body,
        Err(_) => return Err("failed to serialize crdt"),
    };

    let request_url = "http://192.168.1.70:9988/list";
    let response = unwrap_or_return_with!(
        Client::new()
            .put(request_url)
            .json(&json!(&crdt_body))
            .send(),
        Err("Failed to make request")
    );

    println!("Received publish response, status: {}", response.status());

    if response.status().is_success() {
        let mut list = unwrap_or_return!(db.get_list(list_id.clone()));
        list.list_info.shared = true;

        let _ = db.store(list_id, list, "failed to store that list is now shared");
        Ok(true)
    } else {
        Ok(false)
    }
}
