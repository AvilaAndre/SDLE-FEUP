use crate::database::*;
use crate::macros::*;
use crate::model::*;
use std::collections::HashMap;
use crate::crdt::crdt::crdt::{ShoppingList};

use uuid::Uuid;

use unqlite::UnQLite;

//TODO: an user maybe can have also a HashMap with list_Uuid -> list_name: A map of the lists the user have
/**
 * Creates a new user that will use the local app
 */
pub fn create_user(name: &str, age: u32, email: &str, db: &UnQLite){
    let id = Uuid::new_v4().to_string();
    let new_user: User = User{
        node_id: id.clone(),
        name: name.to_string(),
        age: age,
        email: email.to_string(),

    };

    unwrap_or_return!(db.store_user(id.clone(), new_user, "Failed to store new user"));

    return Ok(id);
    
}

pub fn update_user_info(node_id: Uuid, name: String, age: u32, email: String ,db: &UnQLite) -> Result<bool, &'static str> {
    let mut user:User = unwrap_or_return!(db.get_list(node_id.clone()));

    user.name = name.to_string();
    user.age = age;
    user.email = email.to_string();

    return Ok(unwrap_or_return!(db.store_user(
        node_id,
        user,
        "Failed to store updated user"
    )));
}

pub fn get_user( id: String, db: &UnQLite) -> Result<User, &'static str> {
    return db.get_user(id);
}

/**
 *  Creates a new list and returns the created id
 * */
pub fn create_list(title: &str, node_id: Uuid, db: &UnQLite) -> Result<String, &'static str> {
    let mut id = Uuid::new_v4().to_string();//TODO: change this, node_id is generated by the app for the user, before creating any list
    //TODO: the list_id can be a tuple (user_who_created_node_id_using_Uuid, list_id_using_Uuid), now we just use just Uuid
    while db.has_key(id.clone()) {
        id = Uuid::new_v4().to_string();
    }

    let new_list: ShoppingListData = ShoppingListData {
        list_info: ListInfo {
            list_id: id.clone(),//change this to an id using node_id from the user who create the list and a counter/ other information (eg: node_id_user_who_created_list, only-grow counter)
            title: title.to_string(),
            shared: false,
        },
        items_checked: HashMap::new(), //TODO: When an item is checked on the frontend, the name of the item with true value is inserted here. When the item is unchecked/removed the item_name -> True pair is removed
        crdt: ShoppingList::new_v2(node_id),
    };

    unwrap_or_return!(db.store(id.clone(), new_list, "Failed to store new list"));

    return Ok(id);
}

/**
 * Gets the data of a list
 */
pub fn get_list(db: &UnQLite, id: String) -> Result<ShoppingListData, &'static str> {
    return db.get_list(id);
}

/**
 * Gets information about every list in the database
 */
pub fn get_all_lists_info(db: &UnQLite) -> Result<Vec<ListInfo>, &'static str> {
    return db.get_all_lists_info();
}

/**
 *  Adds new list item to a specified list
 * */
pub fn add_item_to_list(
    list_id: String,// Adapt for the id (eg: node_id_user_who_created_list, only-grow counter)
    name: &str,
    qtd: i32,
    db: &UnQLite,
) -> Result<bool, &'static str> {
    let mut list = unwrap_or_return!(db.get_list(list_id.clone()));

    
    list.crdt.add_or_update_item(name.to_string(), qtd);

    return Ok(unwrap_or_return!(db.store(
        list_id,
        list,
        "Failed to store updated list"
    )));
}

/**
 *  Updates a specified list's title
 * */
pub fn update_list_title(list_id: String, title: &str, db: &UnQLite) -> Result<bool, &'static str> {
    let mut list: ShoppingListData = unwrap_or_return!(db.get_list(list_id.clone()));

    list.list_info.title = title.to_string();

    return Ok(unwrap_or_return!(db.store(
        list_id,
        list,
        "Failed to store updated list"
    )));
}

/**
 *  Update an item quantity to 0 when a user locally check an item as complete
 * */
pub fn item_check(list_id: String, item_name: String, db: &UnQLite) -> Result<bool, &'static str> { //TODO: test and do the frontend checkbox
    let mut list: ShoppingListData = unwrap_or_return!(db.get_list(list_id.clone())); 
    //put item quantity to 0
    let reset_decrement = match list.crdt.items.get(&item_name) {
        Some(bounded_pn_counter) => bounded_pn_counter.get_count(),
        None => {
            
            return Err("Item not found in the list");
        }
    };

    
    list.crdt.add_or_update_item(item_name, reset_decrement.try_into().unwrap());

    return Ok(unwrap_or_return!(db.store(
        list_id,
        list,
        "Failed to store updated item quantity"
    )));
}
